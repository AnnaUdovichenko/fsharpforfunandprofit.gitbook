# Summary


### Getting started

* ["Why use F#?" in one page](why-use-fsharp/index.md) 
* [Installing and using F#](installing-and-using/index.md)
* [F# syntax in 60 seconds](posts/fsharp-in-60-seconds.md) 
* [Learning F#](learning-fsharp/index.md)
* [Troubleshooting F#](troubleshooting-fsharp/index.md)
* [Low-risk ways to use F# at work](series/low-risk-ways-to-use-fsharp-at-work.md) 
    * [Twenty six low-risk ways to use F# at work](posts/low-risk-ways-to-use-fsharp-at-work.md)
    * [Using F# for development and devops scripts](posts/low-risk-ways-to-use-fsharp-at-work-2.md)
    * [Using F# for testing](posts/low-risk-ways-to-use-fsharp-at-work-3.md)
    * [Using F# for database related tasks](posts/low-risk-ways-to-use-fsharp-at-work-4.md)
    * [Other interesting ways of using F# at work](posts/low-risk-ways-to-use-fsharp-at-work-5.md)

### Why use F#?

* [The "Why use F#?" Series](series/why-use-fsharp.md) 
    * [Introduction to the 'Why use F#' series](posts/why-use-fsharp-intro.md) 
    * [Comparing F# with C#: A simple sum](posts/fvsc-sum-of-squares.md) 
    * [Comparing F# with C#: Sorting](posts/fvsc-quicksort.md) 
    * [Comparing F# with C#: Downloading a web page](posts/fvsc-download.md)
    * [Four Key Concepts](posts/key-concepts.md) 
    * [Conciseness](posts/conciseness-intro.md) 
    * [Type inference](posts/conciseness-type-inference.md) 
    * [Low overhead type definitions](posts/conciseness-type-definitions.md)
    * [Using functions to extract boilerplate code](posts/conciseness-extracting-boilerplate.md)
    * [Using functions as building blocks](posts/conciseness-functions-as-building-blocks.md) 
    * [Pattern matching for conciseness](posts/conciseness-pattern-matching.md) 
    * [Convenience](posts/convenience-intro.md) 
    * [Out-of-the-box behavior for types](posts/convenience-types.md) 
    * [Functions as interfaces](posts/convenience-functions-as-interfaces.md) 
    * [Partial Application](posts/convenience-partial-application.md) 
    * [Active patterns](posts/convenience-active-patterns.md)
    * [Correctness](posts/correctness-intro.md) 
    * [Immutability](posts/correctness-immutability.md) 
    * [Exhaustive pattern matching](posts/correctness-exhaustive-pattern-matching.md)
    * [Using the type system to ensure correct code](posts/correctness-type-checking.md) 
    * [Worked example: Designing for correctness](posts/designing-for-correctness.md) 
    * [Concurrency](posts/concurrency-intro.md) 
    * [Asynchronous programming](posts/concurrency-async-and-parallel.md) 
    * [Messages and Agents](posts/concurrency-actor-model.md) 
    * [Functional Reactive Programming](posts/concurrency-reactive.md) 
    * [Completeness](posts/completeness-intro.md)
    * [Seamless interoperation with .NET libraries](posts/completeness-seamless-dotnet-interop.md) 
    * [Anything C# can do...](posts/completeness-anything-csharp-can-do.md) 
    * [Why use F#: Conclusion](posts/why-use-fsharp-conclusion.md)

### Thinking Functionally

* [The "Thinking Functionally" Series](series/thinking-functionally.md) 
    * [Thinking Functionally: Introduction](posts/thinking-functionally-intro.md)
    * [Mathematical functions](posts/mathematical-functions.md)
    * [Function Values and Simple Values](posts/function-values-and-simple-values.md)
    * [How types work with functions](posts/how-types-work-with-functions.md)
    * [Currying](posts/currying.md)
    * [Partial application](posts/partial-application.md)
    * [Function associativity and composition](posts/function-composition.md)
    * [Defining functions](posts/defining-functions.md)
    * [Function signatures](posts/function-signatures.md)
    * [Organizing functions](posts/organizing-functions.md)
    * [Attaching functions to types](posts/type-extensions.md)
    * [Worked example: A stack based calculator](posts/stack-based-calculator.md)

### Understanding F# ###
    
* [The "Expressions and syntax" Series](series/expressions-and-syntax.md)         
    * [Expressions and syntax: Introduction](posts/expressions-intro.md)
    * [Expressions vs. statements](posts/expressions-vs-statements.md)
    * [Overview of F# expressions](posts/understanding-fsharp-expressions.md)
    * [Binding with let, use, and do](posts/let-use-do.md)
    * [F# syntax: indentation and verbosity](posts/fsharp-syntax.md)
    * [Parameter and value naming conventions](posts/naming-conventions.md)
    * [Control flow expressions](posts/control-flow-expressions.md)
    * [Exceptions](posts/exceptions.md)
    * [Match expressions](posts/match-expression.md)
    * [Formatted text using printf](posts/printf.md)
    * [Worked example: Parsing command line arguments](posts/pattern-matching-command-line.md)
    * [Worked example: Roman numerals](posts/roman-numerals.md)
* [The "Understanding F# types" Series](series/understanding-fsharp-types.md)             
    * [Understanding F# types: Introduction](posts/types-intro.md)
    * [Overview of types in F#](posts/overview-of-types-in-fsharp.md)
    * [Type abbreviations](posts/type-abbreviations.md)
    * [Tuples](posts/tuples.md)
    * [Records](posts/records.md)
    * [Discriminated Unions](posts/discriminated-unions.md)
    * [The Option type](posts/the-option-type.md)
    * [Enum types](posts/enum-types.md)
    * [Built-in .NET types](posts/cli-types.md)
    * [Units of measure](posts/units-of-measure.md)
    * [Understanding type inference](posts/type-inference.md)
* [Choosing between collection functions](posts/list-module-functions.md)         
* [The "Object-oriented programming in F#" Series](series/object-oriented-programming-in-fsharp.md)     
    * [Object-oriented programming in F#: Introduction](posts/object-oriented-intro.md)
    * [Classes](posts/classes.md)
    * [Inheritance and abstract classes](posts/inheritance.md)
    * [Interfaces](posts/interfaces.md)
    * [Object expressions](posts/object-expressions.md)
* [The "Computation Expressions" Series](series/computation-expressions.md)     
    * [Computation expressions: Introduction](posts/computation-expressions-intro.md)
    * [Understanding continuations](posts/computation-expressions-continuations.md)
    * [Introducing 'bind'](posts/computation-expressions-bind.md)
    * [Computation expressions and wrapper types](posts/computation-expressions-wrapper-types.md)
    * [More on wrapper types](posts/computation-expressions-wrapper-types-part2.md)
    * [Implementing a builder: Zero and Yield](posts/computation-expressions-builder-part1.md)
    * [Implementing a builder: Combine](posts/computation-expressions-builder-part2.md)
    * [Implementing a builder: Delay and Run](posts/computation-expressions-builder-part3.md)
    * [Implementing a builder: Overloading](posts/computation-expressions-builder-part4.md)
    * [Implementing a builder: Adding laziness](posts/computation-expressions-builder-part5.md)
    * [Implementing a builder: The rest of the standard methods](posts/computation-expressions-builder-part6.md)
* [Organizing modules in a project](posts/recipe-part3.md)    
* [The "Dependency cycles" Series](series/dependency-cycles.md)     
    * [Cyclic dependencies are evil](posts/cyclic-dependencies.md)
    * [Refactoring to remove cyclic dependencies](posts/removing-cyclic-dependencies.md)
    * [Cycles and modularity in the wild](posts/cycles-and-modularity-in-the-wild.md)
* [The "Porting from C#" Series](series/porting-from-csharp.md)     
    * [Porting from C# to F#: Introduction](posts/porting-to-csharp-intro.md)
    * [Getting started with direct porting](posts/porting-to-csharp-getting-started.md)


### Functional Design ###

* [The "Designing with types" Series](series/designing-with-types.md)            
    * [Designing with types: Introduction](posts/designing-with-types-intro.md)
    * [Single case union types](posts/designing-with-types-single-case-dus.md)
    * [Making illegal states unrepresentable](posts/designing-with-types-making-illegal-states-unrepresentable.md)
    * [Discovering new concepts](posts/designing-with-types-discovering-the-domain.md)
    * [Making state explicit](posts/designing-with-types-representing-states.md)
    * [Constrained strings](posts/designing-with-types-more-semantic-types.md)
    * [Non-string types](posts/designing-with-types-non-strings.md)
    * [Designing with types: Conclusion](posts/designing-with-types-conclusion.md)
* [Algebraic type sizes and domain modelling](posts/type-size-and-design.md)
* [Thirteen ways of looking at a turtle](posts/13-ways-of-looking-at-a-turtle.md)
    * [Thirteen ways of looking at a turtle (part 2)](posts/13-ways-of-looking-at-a-turtle-2.md)
    * [Thirteen ways of looking at a turtle - addendum](posts/13-ways-of-looking-at-a-turtle-3.md)
    
### Functional Patterns ###
    
* [How to design and code a complete program](posts/recipe-part1.md)    
* [A functional approach to error handling (Railway oriented programming)](posts/recipe-part2.md)    
    * [Railway oriented programming: Carbonated edition](posts/railway-oriented-programming-carbonated.md)
* [The "Understanding monoids" Series](series/understanding-monoids.md)            
    * [Monoids without tears](posts/monoids-without-tears.md)
    * [Monoids in practice](posts/monoids-part2.md)
    * [Working with non-monoids](posts/monoids-part3.md)
* [The "Understanding Parser Combinators" Series](series/understanding-parser-combinators.md)    
    * [Understanding Parser Combinators](posts/understanding-parser-combinators.md)
    * [Building a useful set of parser combinators](posts/understanding-parser-combinators-2.md)
    * [Improving the parser library](posts/understanding-parser-combinators-3.md)
    * [Writing a JSON parser from scratch](posts/understanding-parser-combinators-4.md)
* [The "Handling State" Series](series/handling-state.md)        
    * [Dr Frankenfunctor and the Monadster](posts/monadster.md)
    * [Completing the body of the Monadster](posts/monadster-2.md)
    * [Refactoring the Monadster](posts/monadster-3.md)
* [The "Map and Bind and Apply, Oh my!" Series](series/map-and-bind-and-apply-oh-my.md)        
    * [Understanding map and apply](posts/elevated-world.md)
    * [Understanding bind](posts/elevated-world-2.md)
    * [Using the core functions in practice](posts/elevated-world-3.md)
    * [Understanding traverse and sequence](posts/elevated-world-4.md)
    * [Using map, apply, bind and sequence in practice](posts/elevated-world-5.md)
    * [Reinventing the Reader monad](posts/elevated-world-6.md)
    * [Map and Bind and Apply, a summary](posts/elevated-world-7.md)
* [The "Recursive types and folds" Series](series/recursive-types-and-folds.md)        
    * [Introduction to recursive types](posts/recursive-types-and-folds.md)
    * [Catamorphism examples](posts/recursive-types-and-folds-1b.md)
    * [Introducing Folds](posts/recursive-types-and-folds-2.md)
    * [Understanding Folds](posts/recursive-types-and-folds-2b.md)
    * [Generic recursive types](posts/recursive-types-and-folds-3.md)
    * [Trees in the real world](posts/recursive-types-and-folds-3b.md)
* [The "A functional approach to authorization" Series](series/a-functional-approach-to-authorization.md)        
    * [A functional approach to authorization](posts/capability-based-security.md)
    * [Constraining capabilities based on identity and role](posts/capability-based-security-2.md)
    * [Using types as access tokens](posts/capability-based-security-3.md)

### Testing

* [An introduction to property-based testing](posts/property-based-testing.md)
* [Choosing properties for property-based testing](posts/property-based-testing-2.md)
    
### Examples and Walkthroughs

* [Worked example: Designing for correctness](posts/designing-for-correctness.md) 
* [Worked example: A stack based calculator](posts/stack-based-calculator.md)
* [Worked example: Parsing command line arguments](posts/pattern-matching-command-line.md)
* [Worked example: Roman numerals](posts/roman-numerals.md)
* [Commentary on 'Roman Numerals Kata with Commentary'](posts/roman-numeral-kata.md)
* [Calculator Walkthrough: Part 1](posts/calculator-design.md)
    * [Calculator Walkthrough: Part 2](posts/calculator-implementation.md)
    * [Calculator Walkthrough: Part 3](posts/calculator-complete-v1.md)
    * [Calculator Walkthrough: Part 4](posts/calculator-complete-v2.md)
* [Enterprise Tic-Tac-Toe](posts/enterprise-tic-tac-toe.md).
    * [Enterprise Tic-Tac-Toe, part 2](posts/enterprise-tic-tac-toe-2.md)
* [Writing a JSON parser from scratch](posts/understanding-parser-combinators-4.md)

### Other

* [Ten reasons not to use a statically typed functional programming language](posts/ten-reasons-not-to-use-a-functional-programming-language.md)
* [Why I won't be writing a monad tutorial](posts/why-i-wont-be-writing-a-monad-tutorial.md)
* [Is your programming language unreasonable?](posts/is-your-language-unreasonable.md)
* [We don't need no stinking UML diagrams](posts/no-uml-diagrams.md)
* [Introvert and extrovert programming languages](posts/introvert-vs-extrovert.md)
* [Swapping type-safety for high performance using compiler directives](posts/typesafe-performance-with-compiler-directives.md)