# Summary


### Getting started

* [Why use F#?](/why-use-fsharp/index.md) 
* [Introduction to the 'Why use F#' series](../posts/why-use-fsharp-intro.md) 
* [F# syntax in 60 seconds.](../posts/fsharp-in-60-seconds.md) 
* [Comparing F# with C#: A simple sum.](../posts/fvsc-sum-of-squares.md) 
* [Comparing F# with C#: Sorting.](../posts/fvsc-quicksort.md) 
* [Comparing F# with C#: Downloading a web page.](../posts/fvsc-download.md)
* [Four Key Concepts.](../posts/key-concepts.md) 
* [Conciseness.](../posts/conciseness-intro.md) 
* [Type inference.](../posts/conciseness-type-inference.md) 
* [Low overhead type definitions.](../posts/conciseness-type-definitions.md) No penalty for making new types
* [Using functions to extract boilerplate code.](../posts/conciseness-extracting-boilerplate.md) The functional approach to the DRY principle
* [Using functions as building blocks.](../posts/conciseness-functions-as-building-blocks.md) Function composition and mini-languages make code more readable
* [Pattern matching for conciseness.](../posts/conciseness-pattern-matching.md) Pattern matching can match and bind in a single step
* [Convenience.](../posts/convenience-intro.md) Features that reduce programming drudgery and boilerplate code
* [Out-of-the-box behavior for types.](../posts/convenience-types.md) Immutability and built-in equality with no coding
* [Functions as interfaces.](../posts/convenience-functions-as-interfaces.md) OO design patterns can be trivial when functions are used
* [Partial Application.](../posts/convenience-partial-application.md) How to fix some of a function's parameters
* [Active patterns.](../posts/convenience-active-patterns.md) Dynamic patterns for powerful matching
* [Correctness.](../posts/correctness-intro.md) How to write 'compile time unit tests'
* [Immutability.](../posts/correctness-immutability.md) Making your code predictable
* [Exhaustive pattern matching.](../posts/correctness-exhaustive-pattern-matching.md) A powerful technique to ensure correctness
* [Using the type system to ensure correct code.](../posts/correctness-type-checking.md) In F# the type system is your friend, not your enemy
* [Worked example: Designing for correctness.](../posts/designing-for-correctness.md) How to make illegal states unrepresentable
* [Concurrency.](../posts/concurrency-intro.md) The next major revolution in how we write software?
* [Asynchronous programming.](../posts/concurrency-async-and-parallel.md) Encapsulating a background task with the Async class
* [Messages and Agents.](../posts/concurrency-actor-model.md) Making it easier to think about concurrency
* [Functional Reactive Programming.](../posts/concurrency-reactive.md) Turning events into streams
* [Completeness.](../posts/completeness-intro.md) F# is part of the whole .NET ecosystem
* [Seamless interoperation with .NET libraries.](../posts/completeness-seamless-dotnet-interop.md) Some convenient features for working with .NET libraries
* [Anything C# can do...](../posts/completeness-anything-csharp-can-do.md) A whirlwind tour of object-oriented code in F#
* [Why use F#: Conclusion](../posts/why-use-fsharp-conclusion.md)


### Tutorials


