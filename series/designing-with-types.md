---
layout: series_index
title: "The 'designing with types' series"
seriesIndexId: "Designing with types"
---

In this series, we'll look at some of the ways we can use types as part of the design process. 
In particular, the thoughtful use of types can make a design more transparent and improve correctness at the same time.

This series will be focused on the "micro level" of design. That is, working at the lowest level of individual types and functions. 
Higher level design approaches, and the associated decisions about using functional or object-oriented style, will be discussed in another series.

Many of the suggestions are also feasable in C# or Java, but the lightweight nature of F# types means that it is much more likely that we will do this kind of refactoring.



* [Designing with types: Introduction](../posts/designing-with-types-intro.md). Making design more transparent and improving correctness.
* [Designing with types: Single case union types](../posts/designing-with-types-single-case-dus.md). Adding meaning to primitive types.
* [Designing with types: Making illegal states unrepresentable](../posts/designing-with-types-making-illegal-states-unrepresentable.md). Encoding business logic in types.
* [Designing with types: Discovering new concepts](../posts/designing-with-types-discovering-the-domain.md). Gaining deeper insight into the domain.
* [Designing with types: Making state explicit](../posts/designing-with-types-representing-states.md). Using state machines to ensure correctness.
* [Designing with types: Constrained strings](../posts/designing-with-types-more-semantic-types.md). Adding more semantic information to a primitive type.
* [Designing with types: Non-string types](../posts/designing-with-types-non-strings.md). Working with integers and dates safely.
* [Designing with types: Conclusion](../posts/designing-with-types-conclusion.md). A before and after comparison.
