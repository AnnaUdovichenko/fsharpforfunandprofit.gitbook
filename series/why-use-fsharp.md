---
layout: series_index
title: "The 'Why use F#' series"
seriesIndexId: "Why use F#?"
---

This series of posts will give you a guided tour through the main features of F# and then show you ways that F# can help you in your day-to-day development.


* [Introduction to the 'Why use F#' series](../posts/why-use-fsharp-intro.md). An overview of the benefits of F#
* [F# syntax in 60 seconds](../posts/fsharp-in-60-seconds.md). A very quick overview on how to read F# code
* [Comparing F# with C#: A simple sum](../posts/fvsc-sum-of-squares.md). In which we attempt to sum the squares from 1 to N without using a loop
* [Comparing F# with C#: Sorting](../posts/fvsc-quicksort.md). In which we see that F# is more declarative than C#, and we are introduced to pattern matching.
* [Comparing F# with C#: Downloading a web page](../posts/fvsc-download.md). In which we see that F# excels at callbacks, and we are introduced to the 'use' keyword
* [Four Key Concepts](../posts/key-concepts.md). The concepts that differentiate F# from a standard imperative language
* [Conciseness](../posts/conciseness-intro.md). Why is conciseness important?
* [Type inference](../posts/conciseness-type-inference.md). How to avoid getting distracted by complex type syntax
* [Low overhead type definitions](../posts/conciseness-type-definitions.md). No penalty for making new types
* [Using functions to extract boilerplate code](../posts/conciseness-extracting-boilerplate.md). The functional approach to the DRY principle
* [Using functions as building blocks](../posts/conciseness-functions-as-building-blocks.md). Function composition and mini-languages make code more readable
* [Pattern matching for conciseness](../posts/conciseness-pattern-matching.md). Pattern matching can match and bind in a single step
* [Convenience](../posts/convenience-intro.md). Features that reduce programming drudgery and boilerplate code
* [Out-of-the-box behavior for types](../posts/convenience-types.md). Immutability and built-in equality with no coding
* [Functions as interfaces](../posts/convenience-functions-as-interfaces.md). OO design patterns can be trivial when functions are used
* [Partial Application](../posts/convenience-partial-application.md). How to fix some of a function's parameters
* [Active patterns](../posts/convenience-active-patterns.md). Dynamic patterns for powerful matching
* [Correctness](../posts/correctness-intro.md). How to write 'compile time unit tests'
* [Immutability](../posts/correctness-immutability.md). Making your code predictable
* [Exhaustive pattern matching](../posts/correctness-exhaustive-pattern-matching.md). A powerful technique to ensure correctness
* [Using the type system to ensure correct code](../posts/correctness-type-checking.md). In F# the type system is your friend, not your enemy
* [Worked example: Designing for correctness](../posts/designing-for-correctness.md). How to make illegal states unrepresentable
* [Concurrency](../posts/concurrency-intro.md). The next major revolution in how we write software?
* [Asynchronous programming](../posts/concurrency-async-and-parallel.md). Encapsulating a background task with the Async class
* [Messages and Agents](../posts/concurrency-actor-model.md). Making it easier to think about concurrency
* [Functional Reactive Programming](../posts/concurrency-reactive.md). Turning events into streams
* [Completeness](../posts/completeness-intro.md). F# is part of the whole .NET ecosystem
* [Seamless interoperation with .NET libraries](../posts/completeness-seamless-dotnet-interop.md). Some convenient features for working with .NET libraries
* [Anything C# can do...](../posts/completeness-anything-csharp-can-do.md). A whirlwind tour of object-oriented code in F#
* [Why use F#: Conclusion](../posts/why-use-fsharp-conclusion.md). 
